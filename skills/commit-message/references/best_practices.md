# コミットメッセージのベストプラクティス

効果的なコミットメッセージを書くための実践的なガイドです。

## なぜ良いコミットメッセージが重要か

### メリット

1. **コードレビューの効率化**: 変更の意図を素早く理解できる
2. **デバッグの迅速化**: 問題の原因を特定しやすい
3. **プロジェクト履歴の明確化**: 意思決定の経緯を追跡できる
4. **チーム協業の円滑化**: 他の開発者が変更内容を理解しやすい
5. **自動化の実現**: リリースノートやCHANGELOGの自動生成が可能

### 悪いコミットメッセージの影響

```
❌ fix bug
❌ update code
❌ wip
❌ misc changes
❌ stuff
```

これらのメッセージでは：
- 何が変更されたか分からない
- なぜ変更されたか分からない
- コードレビューに時間がかかる
- バグの原因特定が困難
- プロジェクト履歴が役に立たない

## 7つの黄金律

### 1. 件名と本文を空行で区切る

```
✅ 良い例：
修正：ユーザー登録時のバリデーションエラー
                                    ← 空行
メールアドレスの重複チェックが正しく
動作していなかった問題を修正。

❌ 悪い例：
修正：ユーザー登録時のバリデーションエラー
メールアドレスの重複チェックが正しく
動作していなかった問題を修正。
```

**理由**: `git log --oneline` などで件名のみを表示する際に区別しやすい

### 2. 件名は50文字以内に制限

```
✅ 良い例（46文字）：
fix: ログイン画面のパスワード入力フィールドバグ

❌ 悪い例（78文字）：
fix: ログイン画面でパスワードを入力する際に特殊文字が正しく処理されない問題を修正しました

↓ 改善：本文に詳細を記述
fix: ログイン画面のパスワード処理を修正

特殊文字が含まれるパスワードが正しく
処理されない問題を修正。
```

**理由**:
- GitHubやGitLabは長い件名を省略表示する
- `git log --oneline` で読みやすい
- 簡潔さを強制することで本質を捉える

### 3. 件名の最初の文字を大文字にする（英語の場合）

```
✅ 英語：
Fix login validation error
Add user authentication

✅ 日本語：
修正：ログインのバリデーションエラー
追加：ユーザー認証機能

❌ 英語：
fix login validation error
add user authentication
```

### 4. 件名の末尾にピリオドを付けない

```
✅ 良い例：
feat: ダークモード機能を追加
fix: メモリリークを修正

❌ 悪い例：
feat: ダークモード機能を追加。
fix: メモリリークを修正。
```

**理由**: 件名はタイトルであり、文章ではない

### 5. 命令形を使用する

```
✅ 良い例：
add feature
fix bug
update documentation
追加：新機能
修正：バグ
更新：ドキュメント

❌ 悪い例：
added feature (過去形)
fixing bug (現在進行形)
updates documentation (三人称単数)
機能を追加した (過去形)
```

**理由**: Gitのコミットメッセージは「このコミットを適用すると〜する」という意味を持つ

### 6. 本文は72文字で折り返す

```
✅ 良い例：
fix: データベース接続のタイムアウト

データベース接続プールの設定を見直し、
タイムアウト時間を30秒から60秒に延長。
これにより、高負荷時の接続エラーが
大幅に減少する。

❌ 悪い例：
fix: データベース接続のタイムアウト

データベース接続プールの設定を見直し、タイムアウト時間を30秒から60秒に延長。これにより、高負荷時の接続エラーが大幅に減少する。
```

**理由**:
- ターミナルでの可読性向上
- `git log` コマンドでの見やすさ
- テキストエディタでの編集しやすさ

### 7. 本文で「何を」「なぜ」を説明（「どのように」は最小限）

```
✅ 良い例：
refactor: ユーザー認証ロジックの整理

【なぜ】
認証ロジックが複数のファイルに散在し、
メンテナンスが困難になっていた。

【何を】
認証関連のコードをAuthServiceに集約。
セッション管理とトークン処理を分離。

【結果】
コードの見通しが良くなり、テストも
書きやすくなった。

❌ 悪い例（「どのように」の詳細のみ）：
refactor: ユーザー認証ロジックの整理

auth.jsからauth-service.jsにコードを移動。
Session クラスを作成して session.js に配置。
Token クラスを作成して token.js に配置。
index.js でエクスポート。
```

**理由**: コードを見れば「どのように」は分かる。「なぜ」という意思決定の理由が最も重要

## コミットの粒度

### アトミックコミット

**原則**: 1つのコミット = 1つの論理的な変更

```
✅ 良い例：
Commit 1: feat: ユーザー登録API実装
Commit 2: test: ユーザー登録のテスト追加
Commit 3: docs: API ドキュメント更新

❌ 悪い例：
Commit 1: ユーザー登録機能、ログイン機能、バグ修正、ドキュメント更新
```

### 分割の基準

**分割すべき場合：**
- 異なる機能や修正が含まれる
- 複数のファイルで独立した変更がある
- 後でrevertする可能性がある部分

**1つにまとめてよい場合：**
- 密接に関連する変更
- 片方だけでは動作しない変更
- テストと実装コード（議論の余地あり）

### 実例：適切な分割

**❌ 1つの巨大なコミット：**
```
feat: ユーザー管理機能

- ユーザー登録API
- ユーザー編集API
- ユーザー削除API
- プロフィール画像アップロード
- バリデーション実装
- テスト追加
- ドキュメント更新
- バグ修正3件
```

**✅ 適切に分割：**
```
1. feat: ユーザー登録API実装
2. feat: ユーザー編集API実装
3. feat: ユーザー削除API実装
4. feat: プロフィール画像アップロード機能
5. test: ユーザーAPI のテスト追加
6. docs: ユーザーAPI のドキュメント追加
7. fix: ユーザー登録時のバリデーション修正
8. fix: メール送信エラーハンドリング改善
9. fix: データベーストランザクション処理修正
```

## 「何を」書くべきか

### コンテキストを提供する

```
❌ 不十分：
fix: null pointer exception

✅ 改善：
fix: ユーザープロフィール取得時のnullエラー

ログインしていないユーザーが他のユーザーの
プロフィールにアクセスした際、nullチェックが
不足していたため例外が発生していた。

null チェックを追加し、適切なエラーメッセージを
返すように修正。
```

### ビジネスコンテキストを含める

```
❌ 技術的な説明のみ：
feat: キャッシュ機能追加

Redis を使用したキャッシュ層を実装。

✅ ビジネスコンテキストを含む：
feat: 商品一覧ページのパフォーマンス改善

【背景】
商品一覧ページの読み込みに5秒以上かかり、
ユーザーからのクレームが増加していた。

【対策】
Redisキャッシュを導入し、頻繁にアクセスされる
商品データをキャッシュ。

【結果】
読み込み時間が平均500msに短縮。
直帰率が15%改善。
```

### 影響範囲を明示する

```
feat: 認証方式をJWTに変更

⚠️ 破壊的変更

【影響範囲】
- すべてのAPIエンドポイントで認証方法が変更
- モバイルアプリの更新が必要
- 既存のセッショントークンは無効化

【移行手順】
1. バックエンドをデプロイ
2. フロントエンドをデプロイ
3. ユーザーに再ログインを促す

【移行期限】
2024年3月31日まで旧方式もサポート

詳細: docs/jwt-migration.md
```

## よくあるシナリオ別のベストプラクティス

### バグ修正

```
✅ 理想的なバグ修正コミット：
fix: カート内の商品が重複する問題を修正

【問題】
同じ商品を短時間に複数回追加すると、
カートに重複して登録されていた。

【原因】
カート追加のリクエストが並列実行され、
排他制御が適切に行われていなかった。

【対策】
1. データベーストランザクション追加
2. 商品ID でのユニーク制約を実装
3. フロントエンドでボタンの二重クリック防止

【検証】
- 手動テスト: 100回の連続クリックで問題なし
- 自動テスト: 並列リクエストのテスト追加

Fixes #789
```

### 新機能追加

```
✅ 理想的な機能追加コミット：
feat: メール通知のカスタマイズ機能

【概要】
ユーザーが受け取りたいメール通知を
個別に設定できる機能を追加。

【機能詳細】
- 通知設定画面の追加
- 通知種別ごとのON/OFF設定
- デフォルト設定は全てON

【技術的な実装】
- notification_preferences テーブル追加
- メール送信前に設定をチェック
- 設定画面はReactで実装

【今後の予定】
- プッシュ通知の設定も同じ画面で管理
- 通知頻度の設定（即時/日次/週次）

Closes #456
```

### リファクタリング

```
✅ 理想的なリファクタリングコミット：
refactor: 決済処理ロジックの整理

【背景】
決済処理のコードが肥大化し、
新しい決済方法の追加が困難になっていた。

【変更内容】
1. PaymentService を作成し処理を集約
2. 決済方法ごとにStrategy パターンを適用
   - CreditCardPayment
   - BankTransferPayment
   - EWalletPayment
3. 共通処理を PaymentProcessor に抽出

【保証】
- 全ての既存テストが通過
- 外部から見た動作は完全に同一
- パフォーマンスへの影響なし

【メリット】
- 新しい決済方法の追加が容易
- テストの記述が簡単に
- コードの見通しが大幅に改善
```

### パフォーマンス改善

```
✅ 理想的なパフォーマンス改善コミット：
perf: ユーザー検索のクエリ最適化

【問題】
ユーザー検索に平均2.5秒かかり、
タイムアウトエラーが頻発していた。

【ボトルネック分析】
1. 全文検索のインデックスなし
2. JOIN が5つネストしていた
3. N+1 クエリが発生していた

【最適化内容】
1. search_name カラムに全文検索インデックス追加
2. 不要なJOINを削除し、必要なデータのみ取得
3. eager loading でクエリを1回に集約

【結果】
- 平均応答時間: 2.5秒 → 180ms (93%改善)
- タイムアウトエラー: 0件
- データベース負荷: 60%削減

【計測環境】
- データ件数: 100万件
- 同時アクセス: 100リクエスト/秒
```

### 依存関係の更新

```
✅ セキュリティアップデート：
chore: express を 4.17.1 から 4.18.2 に更新

セキュリティ脆弱性 CVE-2022-24999 の修正を含む。

詳細: https://github.com/advisories/GHSA-xxx

✅ メジャーバージョンアップデート：
chore: React 17 から 18 にアップグレード

【主な変更】
- 新しい concurrent features を利用可能に
- Automatic batching でパフォーマンス向上
- ReactDOM.render から createRoot に移行

【破壊的変更への対応】
- IE11 サポート終了に伴い、ブラウザサポートポリシー更新
- 非推奨 API の置き換え完了
- 全ての自動テストが通過

【移行ガイド】
docs/react-18-migration.md

【動作確認】
- 開発環境: 問題なし
- ステージング環境: 1週間の動作確認完了
```

## アンチパターン

### 1. 曖昧なメッセージ

```
❌ 避けるべき：
fix bug
update code
change stuff
wip
misc
temp
asdf
.

✅ 改善：
fix: ログイン時のセッションタイムアウト
update: ユーザー一覧のソート機能改善
refactor: 日付処理ユーティリティの整理
```

### 2. コミットメッセージにコードを記述

```
❌ 避けるべき：
fix: validation

Changed:
if (user.email) {
  validateEmail(user.email);
}

to:

if (user && user.email) {
  validateEmail(user.email);
}

✅ 改善：
fix: メールバリデーションの null チェック追加

user オブジェクトが undefined の場合に
エラーが発生していた問題を修正。
```

**理由**: コードの差分は `git diff` で見られる

### 3. 複数の無関係な変更を1つのコミットに

```
❌ 避けるべき：
feat: 新機能追加とバグ修正とリファクタリング

✅ 改善：
Commit 1: feat: ダークモード機能追加
Commit 2: fix: プロフィール画像の表示バグ
Commit 3: refactor: CSS クラス名の整理
```

### 4. コミットメッセージが長すぎる

```
❌ 避けるべき（件名が100文字超）：
fix: ユーザーがログインフォームでパスワードを入力してログインボタンをクリックした際にサーバー側でセッションが正しく作成されない問題を修正しました

✅ 改善：
fix: ログイン時のセッション作成エラー

ログイン成功後にセッションが正しく作成されず、
認証が必要なページにアクセスできない問題を修正。

原因: session.save() のコールバック処理が
適切にハンドリングされていなかった。
```

### 5. 過去形や進行形の使用

```
❌ 避けるべき：
Fixed login bug (過去形)
Fixing login bug (進行形)
Fixes login bug (三人称単数)

✅ 改善：
fix: login validation error (命令形)
修正：ログインバリデーションエラー
```

## チーム規約の策定

### プロジェクトでの規約文書例

```markdown
# プロジェクト名 - Gitコミットメッセージ規約

## 基本方針
Conventional Commits を採用し、日本語でコミットメッセージを記述する。

## フォーマット
type: 件名

本文

フッター


## Type 一覧
- feat: 新機能
- fix: バグ修正
- docs: ドキュメント
- style: フォーマット
- refactor: リファクタリング
- test: テスト
- chore: その他

## ルール
1. 件名は50文字以内
2. 本文は必要に応じて記述
3. Issue番号は必須（該当する場合）
4. 破壊的変更は明示

## 例
feat: ユーザー登録機能

メール認証付きのユーザー登録を実装。

Closes #123
```

## ツールでの自動化

### commitlint

```javascript
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      ['feat', 'fix', 'docs', 'style', 'refactor', 'test', 'chore']
    ],
    'subject-max-length': [2, 'always', 50],
    'body-max-line-length': [2, 'always', 72]
  }
};
```

### husky（Git フック）

```json
// package.json
{
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  }
}
```

### commitizen（対話的コミット）

```bash
# インストール
npm install -g commitizen

# 使用
git cz

# 対話的にコミットメッセージを作成
? Select the type of change: feat
? What is the scope: auth
? Write a short description: add password reset
? Provide a longer description:
? Are there any breaking changes? No
? Does this change affect any open issues? Yes
? Add issue references: Closes #123
```

## レビュー時のチェックポイント

コミットメッセージのレビュー項目：

- [ ] 件名は50文字以内で具体的か
- [ ] 変更内容が明確に伝わるか
- [ ] なぜその変更が必要かが説明されているか
- [ ] コミットの粒度は適切か（1つの論理的変更）
- [ ] Issue参照が必要な場合、記載されているか
- [ ] 破壊的変更がある場合、明示されているか
- [ ] 規約に従っているか
- [ ] 文体が統一されているか

## まとめ

良いコミットメッセージの特徴：

1. **明確**: 何をしたか一目で分かる
2. **簡潔**: 不要な情報を含まない
3. **具体的**: 曖昧な表現を避ける
4. **コンテキスト**: なぜその変更が必要かを説明
5. **一貫性**: プロジェクト全体で統一された規約
6. **アトミック**: 1つの論理的変更のみを含む
7. **検索可能**: 後で見つけやすい

**最終目標**: 6ヶ月後に自分や他の開発者がコミット履歴を見て、すぐに変更の意図を理解できること。
